/*
 * Cornell EE/CS 314, Spring 2000.
 * 
 */

import "314/mips.cast";
import "314/parts.cast";
import "314/cpuparts.cast";
import "314/rf.cast";
import "myparts.cast";


/* Decode phase control signals
 *
 * Define me!
 */
define RDctrl() (Bus(32) Irr; node beq, bne, blez, bgtz, bgez, bltz, bgezal, bltzal, j, jr, jalr, jal, lui, cmpto0, targetrs, temp31, 1ext, write, dowrite; node[5] temprdin; node dobranch, dojump;)
{
/*determine the controls for branches and jumps using the Irr*/
node Opcodebra, Opcodebrb, Opcodeja, Opcodejb, bjwrite;
Bus(32) _Irr;

<i:32: Inv() (Irr.d[i],_Irr.d[i]);>

/*Opcodebra equals one if Opcode = 000XXX*/
And3() (_Irr.d[31], _Irr.d[30], _Irr.d[29], Opcodebra);

/*Opcodebrb equals one for bgez, bltz, bltzal, and bgezal if Opcode = 000001*/
And4() (Opcodebra, _Irr.d[28], _Irr.d[27], Irr.d[26], Opcodebrb);

/*beq*/
And4() (Opcodebra, Irr.d[28], _Irr.d[27], _Irr.d[26], beq);

/*bne*/
And4() (Opcodebra, Irr.d[28], _Irr.d[27], Irr.d[26], bne);

/*blez*/
And4() (Opcodebra, Irr.d[28], Irr.d[27], _Irr.d[26], blez);

/*bgtz*/
And4() (Opcodebra, Irr.d[28], Irr.d[27], Irr.d[26], bgtz);

/*bgez*/
And3() (Opcodebra,_Irr.d[19], Irr.d[16], bgez);

/*bltz*/
And4() (Opcodebra, _Irr.d[19], _Irr.d[17], _Irr.d[16], bltz);

/*bgezal*/
And4() (Opcodebra, Irr.d[19], Irr.d[17], Irr.d[16], bgezal);

/*bltzal*/
And4() (Opcodebra, Irr.d[19], Irr.d[17], _Irr.d[16], bltzal);

/*Opcodeja equals one for Opcode = xxx000*/
And3() (_Irr.d[28], _Irr.d[27], _Irr.d[26], Opcodeja);

/*Opcodejb equals one for jr and jalr for Opcode = 000000*/
And2() (Opcodebra, Opcodeja, Opcodejb);

/*j*/
And4() (Opcodebra, _Irr.d[28], Irr.d[17], _Irr.d[26], j);

/*jal*/
And4() (Opcodebra, _Irr.d[28], Irr.d[17], Irr.d[26], jr);

/*jr*/
And4() (Opcodejb, Irr.d[3], _Irr.d[0], jr);

/*jalr*/
And4() (Opcodejb, Irr.d[3], Irr.d[0], jalr);

/*lui (Opcode 001111)*/
And3() x(_Irr.d[31], Irr.d[30], _Irr.d[29]);
And4() (x.out, Irr.d[28], Irr.d[27], Irr.d[26]);


/*decide which bus to send to compare based on control*/
Or4() y(blez,bgtz,bltz,bgez);
Or3() (bltzal,bgezal,y.out,cmpto0);

/*Set dojump for a jump*/
Or4() (j, jal, jr, jalr, dojump);

/*target = rs for jr and jalr*/
Or2() (jr, jalr, targetrs);

/*set register to write to $31 for andlink*/
Or3() (jal, bltzal, bgezal, temp31);

/*determine whether to write for branches and jumps*/
Or4() (jal, jalr, bltzal, bgezal, bjwrite);

/*determine whether to write or not to regs*/
Or2() (write, bjwrite, dowrite);




node 1exttemp,0ext,_0ext;

/* 1ext? is 0 if it is an unsigned number, 1 if it is a signed number*/
/*Branches use an absolute address so 1ext is only set for ALU operations (andi addi and other logical immediate ops) and mem operations*/
/*For unsigned operations 1ext is 0 which is the same as 0 extending */ 
/*1ext will be set for lui but this doesn't matter*/

Or2() (Irr.d[31],Irr.d[29],1exttemp);
And4() (_Irr.d[31],Irr.d[29],_Irr.d[28],Irr.d[26],0ext);
Inv() (0ext,_0ext);
And2() (1exttemp,_0ext, 1ext);





 
}


/* The Decode phase.
 * Not required to be implemented for Part 2
 * Inputs: I - Stage 2 Instruction
 * Outputs: RDcontr() - The control signals generated by this module
 */
define RD() (Bus(32) I, PC;  Bus(32) A, B, Imm; RDctrl rctrl; RF r; Bus(32) Datain, target;)
{
node[5] rs,rt, sftemp1,sftemp2,sftemp3,temp31a,rd;

node kequal,lessthan,greaterthan,tempb,_kequal;

Bus(32) luiwrite, luiwrite2, bus0,cmpin,bjtargettemp,bjtargettemp2a, bjtargettemp2,bjtargettemp3,tgt,bjtargettemp4, bjtargettemp5,PC4temp, PC4temp2,jalwrite,bjtarget;





/*Decode rs and rt from memory*/
<i:16: I.d[i]=Imm.d[i];>
<i:16..31: And2() (I.d[15],rctrl.1ext,Imm.d[i]);>
<i:16..20: rt[i-16]=I.d[i];>
<i:21..25: rs[i-21]=I.d[i];>
<i:11..15: rd[i-11]=I.d[i];>


/*Somewhere we need to set R.RW to the reg number to write Maybe rs or rt from before*/


r.RA=rs;
r.RB=rt;

 negBusFLOP(32) (r.A, A);
negBusFLOP(32) (r.B, B);




/*lui*/
/*set bottom 16 bits to 0*/
<i:16: luiwrite.d[i]=GND;>
/*set top 16 bits to bottom 16 bits of immediate*/
<i:16: luiwrite.d[i+16]=Imm.d[i];> 
<i:32: And2() (luiwrite.d[i],rctrl.lui,luiwrite2.d[i]);>



/*define 0 bus for compare to 0*/
<i:32: bus0.d[i]=GND;>

TBusMux2to1(32) (B, bus0,rctrl.cmpto0,cmpin);
compare() (A,cmpin,kequal,lessthan,greaterthan);
Inv() (kequal,_kequal);

/*set dobranch based on control and results of compare*/
node branch1t,branch2t,branch3t,branch4t,branch5t,branch6t,branch7t,branch8t, temp1,temp2,temp3,temp4;

/*blez*/
Or2() (kequal,lessthan,temp1);
And2() (temp1,rctrl.blez,branch1t);

/*bgtz*/
And2() (rctrl.bgtz,greaterthan,branch2t);

/*bltz*/
And2() (rctrl.bltz,lessthan,branch3t);

/*bgez*/
Or2() (kequal,greaterthan,temp2);
And2() (temp2,rctrl.bgez,branch4t);


/*bgezal*/
And2() (rctrl.bgezal,greaterthan,branch5t);

/*bltzal*/
And2() (rctrl.bltzal,lessthan,branch6t);

/*beq*/
And2() (kequal,rctrl.beq,branch7t);

/*bne*/
And2() (_kequal,rctrl.bne,branch8t);

/*Set dobranch*/
Or4() (branch1t,branch2t,branch3t,branch4t,temp3);
Or4() (branch5t,branch6t,branch7t,branch8t,temp4);
Or2() (temp3,temp4,rctrl.dobranch);


/*Now calculate target for branch*/
/*4 will be added in the IF stage*/
shiftleft2() (Imm,bjtargettemp);
<i:32: And2() (rctrl.dobranch, bjtargettemp.d[i], bjtargettemp5.d[i]);>

/*Set the target for jump*/

/*Decode target.*/
<i:26:tgt.d[i]=I.d[i];>
<i:26..31: tgt.d[i]=GND;>


/*Target=((PC+4)&0xf0000000)|(tgt<<2). */
shiftleft2() (tgt,bjtargettemp4);
<i:28:PC4temp.d[i]=GND;>
<i:28..31: PC4temp.d[i]=Vdd;>
<i:32: And2() (PC4temp.d[i], PC.d[i],PC4temp2.d[i]);>
<i:32: Or2() (PC4temp2.d[i], bjtargettemp4.d[i], bjtargettemp2a.d[i]);>
<i:32: And2() (rctrl.dojump, bjtargettemp2a.d[i], bjtargettemp2.d[i]);>

/*Target=rs for jr and jalr*/
<i:32: And2() (rctrl.targetrs,A.d[i], bjtargettemp3.d[i]);>


/*Determine final target*/
/*Target either equals immediate, value decoded from j format instruction, , or value in a register*/
<i:32: Or3() (bjtargettemp5.d[i],bjtargettemp2.d[i],bjtargettemp3.d[i],bjtarget.d[i]);>

Bus(32) jalrwrite;
node[5] rw;


/*Set register to write (rw) to be $31 for andlink*/
<i:5: rctrl.temp31=temp31a[i];>

/*Otherwise, store PC in $rd for jalr*/
<i:32: jalrwrite.d[i]=PC.d[i];>
/*Eric, I think this is the correct PC but I"m not sure.*/


/*Determine which register number to write*/
/*This might get sketchy if more bits are set*/
/*<i:5: Or3() (temp31a[i],rd[i],rctrl.temprdin[i],r.RW[i]);>*/
r.RW=rctrl.temprdin;



/*Determine which 32 bit bus to write to the register*/
/*We can write the data from wb, the target address, or the shifted immediate for lui*/
Bus(32) Dataintemp,Dataintemp2;

Or4() (jal, jalr, bltzal, bgezal, bjwrite);
TBusMux2to1(32) (bjtarget,Datain, bjwrite,Dataintemp);
TBusMux2to1(32) (Dataintemp,luiwrite2, lui,Dataintemp2);

/*Determine whether or not to write to regs*/
r.WE=rctrl.dowrite;

/*Write to regs*/
negBusFLOP(32) (Dataintemp2, r.W);


}
