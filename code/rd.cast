/*
 * Cornell EE/CS 314, Spring 2000.
 * 
 */

import "314/mips.cast";
import "314/parts.cast";
import "314/cpuparts.cast";
import "314/rf.cast";
import "myparts.cast";


/* Decode phase control signals
 *
 * Define me!
 */
define RDctrl() (Bus(32) Irr; node 1ext, write; node[5] temprdin; node dobranch, dojump, beq, bne, blez, bgtz, bgez, bltz, bgezal, bltzal, j, jr, jalr, jal, lui, cmpto0, targetrs, temp31, bjwrite;)
{

/*determine the controls for branches and jumps using the Irr*/
node Opcodebra, Opcodebrb,Opcodebrb2, Opcodeja, Opcodejb;
Bus(32) _Irr;

<i:32: Inv() (Irr.d[i],_Irr.d[i]);>

/*Opcodebra equals one if Opcode = 000XXX*/
And3() (_Irr.d[31], _Irr.d[30], _Irr.d[29], Opcodebra);

/*Opcodebrb equals one for bgez, bltz, bltzal, and bgezal if Opcode = 000001*/
And4() (Opcodebra, _Irr.d[28], _Irr.d[27], Irr.d[26], Opcodebrb);

/*beq*/
And4() (Opcodebra, Irr.d[28], _Irr.d[27], _Irr.d[26], beq);

/*bne*/
And4() (Opcodebra, Irr.d[28], _Irr.d[27], Irr.d[26], bne);

/*blez*/
And4() (Opcodebra, Irr.d[28], Irr.d[27], _Irr.d[26], blez);

/*bgtz*/
And4() (Opcodebra, Irr.d[28], Irr.d[27], Irr.d[26], bgtz);

/*bgez*/
And3() (Opcodebrb,_Irr.d[20], Irr.d[16], bgez);

/*bltz*/
And3() (Opcodebrb, _Irr.d[20], _Irr.d[16], bltz);

/*bgezal*/
And3() (Opcodebrb, Irr.d[20], Irr.d[16], bgezal);

/*bltzal*/
And3() (Opcodebrb, Irr.d[20], _Irr.d[16], bltzal);

/*Opcodeja equals one for jumps and  Opcode = xxx000*/
And3() (_Irr.d[28], _Irr.d[27], _Irr.d[26], Opcodeja);

/*Opcodejb equals one for jr and jalr for Opcode = 000000*/
And4() (Opcodebra, Opcodeja,_Irr.d[5],_Irr.d[4], Opcodejb);

/*j*/
And4() (Opcodebra, _Irr.d[28], Irr.d[27], _Irr.d[26], j);

/*jal*/
And4() (Opcodebra, _Irr.d[28], Irr.d[27], Irr.d[26], jal);

/*jr*/
And5() (Opcodejb, Irr.d[3],_Irr.d[2],_Irr.d[1], _Irr.d[0], jr);

/*jalr*/
And5() (Opcodejb, Irr.d[3],_Irr.d[2], _Irr.d[1], Irr.d[0], jalr);

/*lui (Opcode 001111)*/
And3() x(_Irr.d[31], _Irr.d[30], Irr.d[29]);
And4() (x.out, Irr.d[28], Irr.d[27], Irr.d[26], lui);


/*decide which bus (bus=0 or RS to send to compare based on control*/
Or4() y(blez,bgtz,bltz,bgez);
Or3() (bltzal,bgezal,y.out,cmpto0);

/*Set dojump for a jump*/
Or4() (j, jal, jr, jalr, dojump);

/*target = rs for jr and jalr*/
Or2() (jr, jalr, targetrs);

/*set register to write to $31 for andlink*/
Or3() (jal, bltzal, bgezal, temp31);

/*determine whether to write for branches and jumps*/
Or5() (lui, jal, jalr, bltzal, bgezal, bjwrite);




node 1exttemp,1exttemp2,0ext,_0ext, 0exttemp, 0exttemp2;

/* 1ext? is 0 if it is an unsigned number, 1 if it is a signed number*/
/*Jumps use an absolute address so 1ext is only set for ALU operations (andi addi and other logical immediate ops and branches) and mem operations*/
/*For unsigned operations 1ext is 0 which is the same as 0 extending */ 
/*1ext will be 0 for lui*/


node _0exttemp,_0exttemp2;

/*Determine whether to 1 ext*/
Or6() (Irr.d[31],Irr.d[30], Irr.d[29],Irr.d[28],Irr.d[27],Irr.d[26], 1exttemp);


/*check for 0ext for lbu and lhu*/
And5() (Irr.d[31], _Irr.d[30], _Irr.d[29], Irr.d[28], _Irr.d[27], 0exttemp);

/*check for 1ext or 0ext for logical ops*/
And4() (_Irr.d[31], _Irr.d[30], Irr.d[29], Irr.d[28],0exttemp2);
Inv() (0exttemp,_0exttemp);
Inv() (0exttemp2,_0exttemp2);
And3() (1exttemp,_0exttemp,_0exttemp2, 1ext);





 
}


/* The Decode phase.
 * Not required to be implemented for Part 2
 * Inputs: I - Stage 2 Instruction
 * Outputs: RDcontr() - The control signals generated by this module
 */
define RD() (Bus(32) I, PC;  Bus(32) A, B, Imm; RDctrl rctrl; RF r; Bus(32) Datain, target, Datatoex; node[5] rdout)
{
node[5] rs,rt, sftemp1,sftemp2,sftemp3,temp31a,rd;

node kequal,lessthan,greaterthan,tempb,_kequal, _targetrs;

Bus(32) luiwrite, luiwrite2, bus0 ,cmpin,bjtargettemp,bjtargettemp2a, bjtargettemp2,bjtargettemp3,tgt,bjtargettemp4, bjtargettemp5,PC4temp, PC4temp2,jalwrite,bjtarget;





/*Decode Imm,rs,rt, and rd from memory*/
<i:16: I.d[i]=Imm.d[i];>
<i:16..31: And2() (I.d[15],rctrl.1ext,Imm.d[i]);>
<i:16..20: rt[i-16]=I.d[i];>
<i:21..25: rs[i-21]=I.d[i];>
<i:11..15: rd[i-11]=I.d[i];>

/*set the register numbers that need to be read from memory*/
r.RA=rs;
r.RB=rt;

/*Get the value of the registers that were read from memory*/
<i:32: A.d[i]=r.A.d[i];>
<i:32: B.d[i]=r.B.d[i];>




/*determine the value of lui performed on the IMM*/
/*set bottom 16 bits to 0*/
<i:16: luiwrite.d[i]=GND;>
/*set top 16 bits to bottom 16 bits of immediate*/
<i:16: luiwrite.d[i+16]=Imm.d[i];> 
<i:32: And2() (luiwrite.d[i],rctrl.lui,luiwrite2.d[i]);>



/*define 0 bus for compare to 0*/
<i:32: bus0.d[i]=GND;>

/*Use either bus B for Bus=0 determined by compto0*/
/*compto0 is used for branches that test against 0*/
TBusMux2to1(32) (B, bus0,rctrl.cmpto0,cmpin);

/*Determine whether A is greaterthan, lessthan, or equal to cmpin*/
compare() c1(A,cmpin,kequal,lessthan,greaterthan);
Inv() (kequal,_kequal);

/*set dobranch based on control and results of compare*/
node branch1t,branch2t,branch3t,branch4t,branch5t,branch6t,branch7t,branch8t, temp1,temp2,temp3,temp4;

/*if the bracketed instruction is true, then the branch?t will hold the result*/
/*then or all the branch?t to get the final result*/
/*only one instruction will be true and at most only one branch?t will have a value.

/*blez*/
Or2() (kequal,lessthan,temp1);
And2() (temp1,rctrl.blez,branch1t);

/*bgtz*/
And2() (rctrl.bgtz,greaterthan,branch2t);

/*bltz*/
And2() (rctrl.bltz,lessthan,branch3t);

/*bgez*/
Or2() (kequal,greaterthan,temp2);
And2() (temp2,rctrl.bgez,branch4t);


/*bgezal*/
And2() (rctrl.bgezal,greaterthan,branch5t);

/*bltzal*/
And2() (rctrl.bltzal,lessthan,branch6t);

/*beq*/
And2() (kequal,rctrl.beq,branch7t);

/*bne*/
And2() (_kequal,rctrl.bne,branch8t);

/*Set dobranch true if any of the branch?t are true*/
Or4() (branch1t,branch2t,branch3t,branch4t,temp3);
Or4() (branch5t,branch6t,branch7t,branch8t,temp4);
Or2() (temp3,temp4,rctrl.dobranch);


/*Now calculate target for branch*/
/*4 will be added to PC in the IF stage*/
shiftleft2() (Imm,bjtargettemp);
<i:32: And2() (rctrl.dobranch, bjtargettemp.d[i], bjtargettemp5.d[i]);>

/*Calculate the target for jump*/
<i:26:tgt.d[i]=I.d[i];>
<i:26..31: tgt.d[i]=GND;>


/*Target=((PC+4)&0xf0000000)|(tgt<<2). */
Inv() (rctrl.targetrs, _targetrs);
shiftleft2() (tgt,bjtargettemp4);
/*PC4temp is used to save the upper four bits of the PC+4*/
<i:28:PC4temp.d[i]=GND;>
<i:28..31: PC4temp.d[i]=Vdd;>
<i:32: And2() (PC4temp.d[i], PC.d[i],PC4temp2.d[i]);>
<i:32: Or2() (PC4temp2.d[i], bjtargettemp4.d[i], bjtargettemp2a.d[i]);>
/*bjtargettemp2 is true if the instruction is a jump*/
<i:32: And3() (_targetrs, rctrl.dojump, bjtargettemp2a.d[i], bjtargettemp2.d[i]);>

/*Target=rs for jr and jalr*/
<i:32: And2() (rctrl.targetrs,A.d[i], bjtargettemp3.d[i]);>


/*Determine final target*/
/*Target either equals immediate, value decoded from j format instruction, , or value in a register*/
<i:32: Or3() (bjtargettemp5.d[i],bjtargettemp2.d[i],bjtargettemp3.d[i],target.d[i]);>

Bus(32) jalrwrite,jalrwritea, jalrwriteb, four, Datatoextemp;
node[5] rw, temprdin2, rt2, rd2;
node _bjwrite, carryout;

/*Set register to write (rw) to be $31 for andlink*/
<i:5: rctrl.temp31=temp31a[i];>

/*Otherwise, store PC+8 in $rd for jalr*/
<i:32: jalrwritea.d[i]=PC.d[i];>
four.d[0]=GND;
four.d[1]=GND;
four.d[2]=Vdd;
<z:3..31: four.d[z]=GND;>
/*Add 8 to PC*/
AddSub32() as(jalrwritea,four,GND,GND,jalrwriteb,carryout);
AddSub32() ab(jalrwriteb,four,GND,GND,jalrwrite,carryout);


/*Determine which register number to write to*/
/*either rd for jalr, rt for lui, $31 for andlink*/
Inv() (rctrl.bjwrite,_bjwrite);
<i:5: And2() (rd[i], rctrl.jalr,rd2[i]);>
<i:5: And2() (rt[i], rctrl.lui, rt2[i]);>
/*Select which register to send along the path*/		
<i:5: Or3() (temp31a[i],rd2[i],rt2[i],rdout[i]);>
	


/*Determine which 32 bit bus to write to the register*/
/*We can write the data from wb, or the shifted immediate for lui*/
/*luiwrite2 is already 0 if rctrl.lui is 0*/
TBusMux2to1(32) (bus0, jalrwrite, rctrl.bjwrite, Datatoextemp);
TBusMux2to1(32) (Datatoextemp, luiwrite2, rctrl.lui, Datatoex);


rctrl.temprdin=r.RW;		
/*Determine whether or not to write to regs*/
r.WE=rctrl.write;

/*Write to regs*/
<i:32: r.W.d[i]=Datain.d[i];>


}
